What is an API? What are Web APIs? Application Programming Interface set of
rules which allow software applications to communicate with each other and
exchange data efficiently Types of API: Web APIs are specifically desighned for
web applications there are different types of web api for client-side JS
development but they are not part of JS itself Browser APIs expose data from the
browser. You can access and manipulate this data using JS Also provide access to
functionalities such as handling events, working with storage, communicating
with network. Some examples of commonly used Browser APIs include The DOM API,
which you can use to manipulate HTML elements, their styles and attributes. The
Storage API, to store data locally on the user's device You can also work with
other types of elements, such as video and audio Third-party APIs: Google Maps
API, you can use to display interactive maps on your website. weather APIs
social media APIs payment APIstranslation APIs What is DOM? Document Object
Model programming interface that lets us interact with HTML documents With DOM
you can modify, add, delete elements on a webpage You can make your website
interactive by making elements listen to and respond to events In the DOM, an
HTML document is represented as a tree of nodes. Each node represents an HTML
element from the HTML document Basic DOM structure Document -------- HTML
-------- - Head - Title - Body - H1 - H2 HTML document is the root node of DOM
hierarchy It has one child node, the html element. This is the root element of
the HTML document, all other nodes descend from it The html element has two
children: head and body The head element contains metadata about the document,
provides essential information about the webpage The body element contains the
visible content of the webpage You can access these elements in JS, you can use
getElementById() and querySelector() methods. These methods are web APIs, they
provide standardized ways to interact with the DOM using JS With
getELementById(), you can access by id, its unique in every element, return only
one Element Object const container = document.getElementById("container");
querySelector() is broader than getElementById(), you can get the first element
in the HTML document that matches the CSS selector passed as argument
<section></section>
const sectionEl = document.querySelector("section") if you want select an
element by its class name, you can use (.) const highlightEl =
document.querySelector(".highlight") How to DOM Nodes Exist Relative to each
other in the DOM Tree? DOM Nodes and their relationtiop in the DOM Tree DOM
Nodes also have direct and indirect relationships with one another.
<html>
  <head>
    <title>DOM Tree Example</title>
  </head>
  <body>
    <h1>Heading 1</h1>
    <p>Paragraph 1</p>
    <ul>
      <li>List item 1</li>
      <li>List item 2</li>
    </ul>
  </body>
</html>
The root of the DOM tree is the html element, its top-level container for all
the content of an HTML document. All other nodes are descendants of this root
node body- parent of the paragraph while paragraph is the child of the body We
have parent and child nodes, we also have sibling nodes. Sibling nodes are
elements that share the same parent. The two list item elements share the same
unordered list parent, so they're siblings We also have indirect relationships
across different levels in the hierarchy. Descendant nodes are elements that are
contained within another element. In example li elements are descendants of the
body, since they are indirectly contained within it. An ancestor nodes is an
element that is higher up in the DOM tree hierarchy than another element. body
is ancestor of the list item li elements. What is the querySelectorAll() method.
You can use this method to get a list of all the DOM elements that matches a
specific CSS Selector. document.querySelectorAll(selectors); the srgument should
be a valid CSS Selector, otherwise will be SyntaxError querySelectorAll()
returns a NodeList object, a collection of nodes that match the specified CSS
Selector. This list will contain one Element object for each element that
matches the CSS Selectors. If no matches are found, the list will be empty. if
tag -> just "div" if class -> just ".className" if id -> just "#id" if el with
specific attribute, like links -> "a[href='https://www.freecodecamp.org/']" you
can also use more complex CSS selectors -> "ul.ingredients li"
<ul class="ingredients">
  <li>Flour</li>
  <li>Cheese</li>
  <li>Water</li>
</ul>
const matches = document.querySelectorAll("ul.ingredients li") will return //
NodeList(3) { 0: `
<li>Flour</li>
`, 1: `
<li>Cheese</li>
`, 2: `
<li>Water</li>
`, length: 3, } you can log this nodelist, and also check the length, output
will be integer you can also access the individual elements, by its indices.
matches[0] ->
<li>Flour</li>
you can also iterate over the elements with for loop

Create New Nodes using
innerHTML and createElement() You can create nodes with innerHTML and
createElement() 
innerHTML is a property of Element objects that you can use to
set their HTML markup. With innerHTML, you can set the HTML structure of an
existing element with a string, creating all the necessary nodes.
<div id = "container"> </div>
const container = document.getElementById("container");
container.innerHTML = "<ul><li>Cheese</li><li>Tomato</li></ul>"
we will set the innerHTML of this element to an unordered list
after running this code the html structure will be 
<div id="container">
  <ul>
    <li>Cheese</li>
    <li>Tomato</li>
  </ul>
</div>
new nodes were created and added dynamically to the DOM after the string was parsed
But you shouldn't use it if you won't have full control over the string
if string entered by user, you shouldn't use innerHTML, cause the user might insert malicious content into your website,
cause of this, it's usually recommended to use textContent instead, to insert plain text

another way to create new nodes is by using the createElement() method.
with this method, you can create a new element by specifying its tag name.
for example, if you want to create an image element, you would pass the img tag as a string when calling this method
document.createElement("img");
const img = document.createElement("img") -> you assign this object to variable
createElement() returns a new HTMLElement object if the document is an HTMLDocument. Else, returns an Element object.
Once you have this new element ready, you can add it to the DOM as a child of another existing element using the appendChild(),
or you can insert it at a specific location using other methods.
const container = document.getElementById("container");
const img = document.createElement("img");
img.src = "https://cdn.freecodecamp.org/curriculum/cat-photo-app/lasagna.jpg";
img.alt = "A slice of lasagna on a plate.";
container.appendChild(img);
creating nodes with innerHTML and createElement() allows you to dynamically manipulate the structure and content of your websited.

Difference between innerText, textContent, innerHTML
--- innerText represents the visible text content of the HTML element and its descendants, this property doesn't include hidden text or HTML tags, only rendered text.
<div id="container">
  <p>Hello, World!</p>
  <p>I'm learning JavaScript</p>
</div>
const container = document.getElementById("container");
console.log(container.innerText); // Hello, World! and I'm learning
property returns a string with the text contained within the element. If child element is hidden, its text wont be visible
--- textContent returns the plainText content of an element, including all the text within its descendants
difference between innerText and textContent is that textContent always returns the full text content and HTML element and its descendents, regardless of whether it's visible or hidden
textContent will also include the content of elements like script and style
If you try to replace the value of textContent on a node, it will remove all its child nodes and replace them with a single text node containing the new string
Difference between innerText, textContent, innerHTML - with innerHTML you can set the inner HTML content of an element. This is helpful for injecting new HTML into the DOM dynamically.

Add and Remove nodes from the DOM with appendChild() and removeChild()
The appendChild() method is used to add a node to the end of the list of children of a specified parent node.
Syntax
parentNode.appendChild(newNode);
const dessertList = document.getElementById("desserts");
const newItem = dessertsList.createElement("li");
dessertList.appendChild(newItem) -> but last added el is empty
to add text content to the new list item element, you can use the textContent
newItem.textContent = "Cookies"
dessertList.appendChild(newItem)
The removeChild() method 
parentNode.removeChild(childNode)
const sectionEl = document.getElementById("example-section");
const lastParagraph = document.querySelector("#example-section p:last-of-type");
last-of-type -> pseudo-class to select the last element inside section element
sectionEl.removeChild(lastParagraph)

Navigator Window and Document interfaces
An interface is a collection of methods and properties that define a particular object
The Navigator interface provides information about the browser environment, such as the user agent string, the platform and the version of the browser.
A user agent string is a text that defines the browser and operating system being used
console.log(navigator.userAgent) -> result will be string that contains information about browser and operating system that being used
result's like -> Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/128.0.0.0 Safari/537.36
Another useful property of Navigator is language property, which returns the lanuage of the browser. You can use it when to display content in the user's preferred language
console.log(navigator.language) -> result will be string like en-US

The Window interface represents the browser window that contains the DOM document. It provides methods and properties for interacting with the browser window, such as resizing the window, opening new window, and navigating to different URLs
console.log(window.innerWidth) -> like 800 in pixels
console.log(window.location) -> information about the current URL of the browser window, result will be object such as protocol, hostname, pathname
Mostly you wont need to interact with the Window interface directly, as it's automatically available in the global scope
you can use location without window, like
console.log(location)-> results will be same as window.location
The Document interface represents the DOM document that is displayed in the browser window. It provides methods and properties for interacting with the DOM, such as selecting elements, creating new elements, and modifying the content of elements
console.log(document.children)-> result will be HTMLCollection object that contains all the child elements of the document

add Attributes with setAttributes()
setAttribute() method to add attributes to your HTML elements
Syntax
setAttribute(attribute, value);
<p id="para">I am a paragraph</p>
to add a class attribute we need to access that p element then use setAttribute()
const paragra = document.getElementById("para")
paragra.setAttribute("class", "my-class")
console.log(${paragra.outerHTML}) ->   <p id="para" class="my-class">I am a paragraph</p>
or you can update existing attr to new one
const pEl = document.querySelector(".my-class");
pEl.setAttribute("class", "example")
console.log(${pEl.outerHTML})
if you were buildinf image gallery, you might need to update src attr of image element, when user clicks on a thumbnail

Event object
is a payload that triggers when a user interact with your web page in some way. 
These interactions can be anything from clicking on a button or focusing an input to shaking their mobile device.
Event object has a number of properties that might be helpful, properties available depend on the event that triggered this payload.
type property - reveals the type of event that triggered the payload, such as "keydown"/"click".
These values will correspond to the same values you might pass to addEventListener(), where you can capture and utilize the Event object.
target property - reference to whatever object triggered the event. This will be sort of HTML element object, or the Document/ Window objects. But it can be also something more specific, like an AudioContext.
Event also have methods which are functions exposed as properties on the object. One commonly used method is preventDefault(), which prevents the default behavior of the event when called.
If you want handle form submissions yourself, for example, you might call preventDefault() to keep the browser from trying to submit the from data as a POST request. 
stopPropagation() method - prevents the event from bubbling up or propagating to parent elements.
FetchEvent - have a request property to contain the request that triggered the event.

addEventListener() method
is used to listen for events. It takes two arguments: the event you want to listen for and a function that will be called when the event occurs
Syntax:
element.addEventListener("event", listener);
element is the HTML element to monitor for events
event specifies the type of event to listen for, such as "click"
The listener is an object that will recieve the notification when the event occurs. this will be a function that you define to handle the event.
element.addEventListener("click", ()=>{})
the listener argument can also be null, or it can be an object tha uses the EventListener interface.
EventListener defines a single method called handleEvent().
This method is automatically called whenever the event you're listening for occurs. Using this interface allows same object to handle multiple events if needed.

<button id="btn">Show alert</button>
const btn = document.getElementById("btn");
btn.addEventListener("click", ()=> alert("You cliked the button"))

<input type="text" id="input" placeholder="Type something" />
const input = document.getElementById("input");
input.addEventListener("input", ()=>{
  console.log(input.value)
})
There are common events include mouseover, mouseout, keydown, keyup, submit

removeEventListener() method
is used to remove an event listener that was previously added to an element using the addEventListener() method.
Useful when you want to stop listening for a particular event on an element.
Syntax:
element.removeEventListener("event", listener);
There is also an additional optional third argument that can be passed to the removeEventListener() method. This argument can either be the options or useCapture.
The options is an object that specifies the options for the event listener, such as whether the event listener should be passive or once.
The useCapture is a boolean value that specifies whether the event should be captured during the event propagination phase.
Most of time you will only need to pass the event and listener arguments
We might use the removeEventListener() method in a real-world application, when modal is closed or when a user logs out

Inline Event Handlers and why is it best practice to use eddEventListener() instead
are special attributes on an HTML element that are used to execute JS code when an event occurs.
<button onclick ="alert('Hello')">Show alert</button>
when user clicks on the button, the alert function is called and an alert dialog is displayed with the msg
another way to use inline event handlers is to call a function that is defined in a script tag in HTML document.
<button onclick=""changeColor()>Change bg color</button>
<script> 
  function changeColor(){
    document.body.style.backgroundColor = "lightblue"
  }
</script>
Inline event handlers can only be used to attach one event listener to an element. If you want to attach multiple event listeners to the same element, you will need to use addEvenListener().
Inline event handlers mix HTML and JS code together, which can make your code harder to rean and maintain.
Inline event handlers are not recommended for use in modern JS.
Its better to use addEventListener()

Manipulate styles using Element.style and Element.classList
The Element.style property is a read-only property that represents the inline style of an element. You can use this property to get or set the style of an element.
<p id="para">This is a para</p>
const paraEl = document.getElementById("para")
paraEl.style.color = "red"
style property can be used to set many CSS properties, such as color, background-color, font-size, font-weight, and so on.
The Element.ClassList is a read-only property that can be used to add, remove, or toggle classes on an element.
const paraEl = document.getElementById("para")
paraEl.classList.add("highlight"); // we are adding class highlight to paragraph with id para
classList.add("class1", "class2", "class3"); //you can also add multiple classes
classList.remove("highlight"); // you can remove class from an element 
classList.toggle() // to toggle a class on an element
<button id="toggle-btn">Toggle Menu</button>
<nav id="menu" class="menu">
  <ul>
    <li>Home</li>
  </ul>
</nav>
.menu {
  display: none;
  background-color: lightgray;
  width: 50%;
  padding: 10px;
}
.menu.show {
  display: block;
}
const menu = document.getElementById("menu");
const toggleBtn = document.getElementById("toggle-btn");
toggleBtn.addEventListener("click", () => menu.classList.toggle("show"));
when user clicks on the button, the show class will be added to the .menu element, and the menu element will be displayed.
If user clicks again, the show will be removed from .menu, and menu will be hidden.

DOMContentLoaded Event 
is fired when everything in the HTML document has been loaded and pardsed. If you have external stylesheets or images, the DOMContentLoaded event will not wait for those to be loaded. It will only wait for the HTML to be loaded.
this differs from the load event, which waits for everything to be loaded, including external stylesheets, images and so on.
Syntax
document.addEventListener("DOMContentLoaded", function(){
  console.log("DOM is Loaded.")
}) //Once DOM is loaded, the function will be executed and the msg Dom is loaded, will be logged to the console.
if (document.readyState === "loading") {
  document.addEventListener("DOMContentLoaded", changeImg);
} else {
  console.log("DOMContentLoaded has already fired");
  changeImg();
}
//this code makes sure that the function changeImg() runs only after the HTML document is fully loaded and parsed, no matter when the script itself is executed.

setTimeout and setInterval methods
both methods accept two parameters: a function and a delay
setTimeout() lets you delay an action for a specified time. 
Syntax
setTimeout(functionToRun, delay)
functionToRun is the code you want to execute after a specified delay, 
delay is the time to wait before running the function.
setTimeout(function(){
  console.log("This runs in 3 seconds")
}, 3000)
you can also use an arrow function for the callback
setTimeout(()=>{console.log("This runs in 3 seconds")}, 3000)
setInterval() keeps repeating a function at a set interval.
It's like an alarm that goes off every few seconds, it's useful when you want smth to happen over and over again.
Syntax
setInterval(functionToRun, delay)
functionToRun is the code you want to run repeatedly, 
delay is the time in milliseconds between each execution of that function.
setInterval(()=>{console.log("This repeats every 3 seconds")}, 3000)
If you want to stop it, you have to use the clearInterval() method.
clearInterval() takes the ID of the setInterval() you want to stop.
This could be a variable you assign to interval to.
const interValID = setInterval(()=>{console.log("This will stop after 5 seconds")}, 1000);
setTimeout(()=>{clearInterval(intervalId)},5000)
you can also stop a timeout with the clearTimeout() method
let timeoutID = setTimeout(()=>{console.log("this wont run")}, 5000)
clearTimeout(timeoutID)
More elegant way to do it is through DOM, by adding event listener to a button
const btn = document.getElementById("cancelButton")
btn.addEventListener("click", ()=>{
  clearTimeout(timeoutID)
  console.log("Timeout canceled.")
})

requestAnimationFrame() API, how can it be used to Set Up an Animation Loop
is a method that allows you to schedule the next step of your animation before the next screen repaint, resulting in a fluid and visually appealing experience.
The next screen repaint refers to the moment when the browser reffreshes the visual display of the web page. This happens multiple times per second, typically around 60 times on most displays.
To use method you need to call it and pass a callback function into it.
Syntax
requestAnimationFrame(callback)
calling requestAnimationFrame() must first occur inside a function that handles the animation, such as animate(), along with a function to update the animation, traditionally called update()
function animate(){
  update()
  requestAnimationFrame(animate);
}
The update() function is where the magic happens. Inside it, you get to change whatever you want to animate. F/e: updating a style or changing the position of an element.
function update(){
  element.style.transform = `translateX(${position}px)`
  position +=2;
}
What finally kicks off the animation is calling requestAnimationFrame() and passing in the animate function, this time outside the animate function
The loop will continue until you stop it.

Web Animations API, and how does it relate to CSS Animation properties
WAAPI allows you to create and control animations directly within JS. With WAAPI you can work with animations more dynamically, making it easier to manipulate them.
At the core of WAAPI is the Animation constructor, which provides several instance methods and properties that allow you to dynamically animate elements.
A significant method in the Animation constructor is animate(). It allows you to create an animation by specifying keyframes and options like duration, direction, easing, iterations.
Syntax 
element.animate(keyframes, options);
<div id="square" class="square"></div>
.square {
  background: #1b1b32;
  width: 10rem;
  aspect-ratio: 1/1;
}
const square = document.querySelector("#square")
const animation = square.animate(
  [{transform: "translateX(0px)" }, {transform: "translateX(100px)"}],
  {
    duration: 2000, // makes animation lasts 2 seconds
    iterations: Infinity, // loops indefinetely
    direction: "alternate", //move back and forth
    easing: "ease-in-out" //smooth easing
  }
)
The result in the browser will be a blue square moving back and forth hotizontally.
The instance methods of the Animation constructor include:
play() 
pause()
reverse()
finish()
cancel()
The instance properties include
playbackRate
currentTime
startTime
effect
timeline 
playState
finished 
onfinish
oncancel
<div id="square" class="square"></div>
<button id="playBtn">Play</button>
<button id="pauseBtn">Pause</button>
const square = document.querySelector("#square");
const playBtn = document.querySelector("#playBtn");
const pauseBtn = document.querySelector("#pauseBtn");
const animation = square.animate(
  [{ transform: "translateX(0px)" }, { transform: "translateX(200px)" }],
  {
    duration: 5000, // Animation lasts 5 seconds
    direction: "alternate", // Moves back and forth
    easing: "ease-in-out" // Smooth easing function
  }
);
animation.onfinish =()=>{
  console.log("Animation finished.")
}
playBtn.addEventListener("click", ()=>{
  animation.play()
  console.log("You start the animation.")
})
pauseBtn.addEventListener("click", ()=>{
  animation.pause()
  console.log("You pause the animation.")
})
The result in the browser will show the blue box moving from left to right when the play button is clicked.
The difference is that you can control the animations you create with the animate() method more directly and dynamically, but with CSS animations, you need to do way more by defining custom styles and triggering tham inside your JS code.
CSS animation is ideal for simple and declarative animations that run automatically. Those include hover effects, transitions or animations that dont need much interaction once triggered. If your animation needs to respond to user interactions like clicks, scrolls, or you want the user to be able to pause,reverse, or change speed dynamically, WAAPI is the better choice.

Canvas API
is a powerful tool that lets manipulate graphics right inside your JS file.
Everything begins with canvas element in HTML.
This element serves as a drawing surface that you can manipulate using the instance methods and properties of the Canvas API.
The Canvas API provides everything you need to create amazing visuals, including shapes, text, animations and even complex games.
It has interfaces like HTMLCanvasElement, CanvasRenderingContext2D, CanvasGradient, CanvasPattern, TextMetrics which provides methods and properties you can use to create graphics in your JS file.
<canvas id="my-canvas"></canvas>
<canvas id="my-canvas" width="400" height="400"></canvas>
or you can do it
const canvas = document.getElementById("my-canvas")
canvas.width = 400;
canvas.height = 400;
after creating canvas element, you need to get access to the drawing context of the canvas with the getContext() method of the HTMLCanvasElement interface.
the most common context is 2d, which allows you to draw in two dimensions:
const ctx = canvas.getContext('2d')
if you log ctx to the console, you'll see the methods and properties of CanvasRenderingContext2D that you can use to create shepes, colors, lines, and more, along with their default values.
console.log(ctx)
Once you have the 2D context, you can start drawing on the canvas.
fillStyle property, you can combine with the fillRect() method to draw a rectangle or square.
<canvas id="my-canvas" width="400" height="400"></canvas>
const canvas = document.getElementById("my-canvas")
const ctx = canvas.getContext("2d");
ctx.fillStrule = "crimson" // set bg color
ctx.fillRect(1,1,150,100) // draw a rectangle
fillRect takes 4 number values, x axis, y axis, width, height
you can also draw text or create an animation.
ctx.font = "30px Arial"
ctx.fillStyle = "crimson"
ctx.fillText("Hello Canvas", 1, 50)
the result in the browser will be the red text Hello Canvas.

Open and close Dialog elements using JS
With HTMl dialog element, you can easily create these dialogs(both modal and non-modal dialogs) in web apps.
A modal dialog is a type of dialog that forces the user to interact with it before thay can access the rest of the application or webpage.
It effectively blocks interaction with other content until the user completes an action, such as closing dialog or submitting a form.
A non-modal dialog allows the user to cocntinue interacting with other parts of the page or application even when the dialog is open. It doesnt prevent access to the rest of the content.
showModal() method will add a backtop to the other items on the page and disable them. This is ideal for modals that display forms, confirmations, and critical information that requires user action.
You can use it when you want to make sure the user focuses on a specific action or message of a modal, you can open the modal dialog.
<dialog id="modal"><p>This is a modal dialog.</p></dialog>
const dialog = document.getElementById("modal")
dialog.showModal();
the result in the browser will show a modal with the text This is a modal dialog.
If you needed to show a dialog while still allowing interaction with content outside of the dialog, then you can use the show() method.
<dialog id="modal">
  <p>This is a modal dialog.</p>
</dialog>
const dialog = document.getElementById("modal");
dialog.show();
To close a modal, you can add a button to the modal inside the dialog element and use the close() method.
const openButton = document.getElementById("open-modal-btn");
const closeButton = document.getElementById("close-modal-btn");
openButton.addEventListener("click", () => {
  dialog.show();
});
closeButton.addEventListener("click", () => {
  dialog.close();
});

Change Event
is a special event which is fired when the user modifies the value of certain input elements. More specifically:
when a checkbox is ticked or unticked; when a radio button is ticked; when the user makes a selection from something like a date or dropdown menu; when an input loses focus(the user tabs to the next field, or clicks out of the form) after the user has changed the value; when the user otherwise confirms the value, such as by hitting enter after typing some text.
Note that the change event doesnot fire when your user types in an input. The change event will only fire after they have focused on another element.
Example of using the change event with a dropdown menu:
<select name="" id="select-menu">
  <option value="option1">Option 1</option>
  <option value="option2">Option 2</option>
  <option value="option3">Option 3</option>
</select>
const selectMenu = document.getElementById("select-menu")
selectMenu.addEventListener("change", (event)=>{
  console.log(`You selected: ${event.target.value}`)
})
Each time the user selects a different option from the dropdown menu, the change event will fire, and the selected value will be logged to the console.
The change event still generates an Event object, but unlike most other events it does not generate a custom implementation - the only properties and methods you will have access to are those on the base Event object.
This differs from the input event, which generates a dedicated InputEvent object. The change event also differs in a few ways. An input event WILL trigger when a user types content into a field.
