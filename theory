What is an API? What are Web APIs? Application Programming Interface set of
rules which allow software applications to communicate with each other and
exchange data efficiently Types of API: Web APIs are specifically desighned for
web applications there are different types of web api for client-side JS
development but they are not part of JS itself Browser APIs expose data from the
browser. You can access and manipulate this data using JS Also provide access to
functionalities such as handling events, working with storage, communicating
with network. Some examples of commonly used Browser APIs include The DOM API,
which you can use to manipulate HTML elements, their styles and attributes. The
Storage API, to store data locally on the user's device You can also work with
other types of elements, such as video and audio Third-party APIs: Google Maps
API, you can use to display interactive maps on your website. weather APIs
social media APIs payment APIstranslation APIs What is DOM? Document Object
Model programming interface that lets us interact with HTML documents With DOM
you can modify, add, delete elements on a webpage You can make your website
interactive by making elements listen to and respond to events In the DOM, an
HTML document is represented as a tree of nodes. Each node represents an HTML
element from the HTML document Basic DOM structure Document -------- HTML
-------- - Head - Title - Body - H1 - H2 HTML document is the root node of DOM
hierarchy It has one child node, the html element. This is the root element of
the HTML document, all other nodes descend from it The html element has two
children: head and body The head element contains metadata about the document,
provides essential information about the webpage The body element contains the
visible content of the webpage You can access these elements in JS, you can use
getElementById() and querySelector() methods. These methods are web APIs, they
provide standardized ways to interact with the DOM using JS With
getELementById(), you can access by id, its unique in every element, return only
one Element Object const container = document.getElementById("container");
querySelector() is broader than getElementById(), you can get the first element
in the HTML document that matches the CSS selector passed as argument
<section></section>
const sectionEl = document.querySelector("section") if you want select an
element by its class name, you can use (.) const highlightEl =
document.querySelector(".highlight") How to DOM Nodes Exist Relative to each
other in the DOM Tree? DOM Nodes and their relationtiop in the DOM Tree DOM
Nodes also have direct and indirect relationships with one another.
<html>
  <head>
    <title>DOM Tree Example</title>
  </head>
  <body>
    <h1>Heading 1</h1>
    <p>Paragraph 1</p>
    <ul>
      <li>List item 1</li>
      <li>List item 2</li>
    </ul>
  </body>
</html>
The root of the DOM tree is the html element, its top-level container for all
the content of an HTML document. All other nodes are descendants of this root
node body- parent of the paragraph while paragraph is the child of the body We
have parent and child nodes, we also have sibling nodes. Sibling nodes are
elements that share the same parent. The two list item elements share the same
unordered list parent, so they're siblings We also have indirect relationships
across different levels in the hierarchy. Descendant nodes are elements that are
contained within another element. In example li elements are descendants of the
body, since they are indirectly contained within it. An ancestor nodes is an
element that is higher up in the DOM tree hierarchy than another element. body
is ancestor of the list item li elements. What is the querySelectorAll() method.
You can use this method to get a list of all the DOM elements that matches a
specific CSS Selector. document.querySelectorAll(selectors); the srgument should
be a valid CSS Selector, otherwise will be SyntaxError querySelectorAll()
returns a NodeList object, a collection of nodes that match the specified CSS
Selector. This list will contain one Element object for each element that
matches the CSS Selectors. If no matches are found, the list will be empty. if
tag -> just "div" if class -> just ".className" if id -> just "#id" if el with
specific attribute, like links -> "a[href='https://www.freecodecamp.org/']" you
can also use more complex CSS selectors -> "ul.ingredients li"
<ul class="ingredients">
  <li>Flour</li>
  <li>Cheese</li>
  <li>Water</li>
</ul>
const matches = document.querySelectorAll("ul.ingredients li") will return //
NodeList(3) { 0: `
<li>Flour</li>
`, 1: `
<li>Cheese</li>
`, 2: `
<li>Water</li>
`, length: 3, } you can log this nodelist, and also check the length, output
will be integer you can also access the individual elements, by its indices.
matches[0] ->
<li>Flour</li>
you can also iterate over the elements with for loop

Create New Nodes using
innerHTML and createElement() You can create nodes with innerHTML and
createElement() 
innerHTML is a property of Element objects that you can use to
set their HTML markup. With innerHTML, you can set the HTML structure of an
existing element with a string, creating all the necessary nodes.
<div id = "container"> </div>
const container = document.getElementById("container");
container.innerHTML = "<ul><li>Cheese</li><li>Tomato</li></ul>"
we will set the innerHTML of this element to an unordered list
after running this code the html structure will be 
<div id="container">
  <ul>
    <li>Cheese</li>
    <li>Tomato</li>
  </ul>
</div>
new nodes were created and added dynamically to the DOM after the string was parsed
But you shouldn't use it if you won't have full control over the string
if string entered by user, you shouldn't use innerHTML, cause the user might insert malicious content into your website,
cause of this, it's usually recommended to use textContent instead, to insert plain text

another way to create new nodes is by using the createElement() method.
with this method, you can create a new element by specifying its tag name.
for example, if you want to create an image element, you would pass the img tag as a string when calling this method
document.createElement("img");
const img = document.createElement("img") -> you assign this object to variable
createElement() returns a new HTMLElement object if the document is an HTMLDocument. Else, returns an Element object.
Once you have this new element ready, you can add it to the DOM as a child of another existing element using the appendChild(),
or you can insert it at a specific location using other methods.
const container = document.getElementById("container");
const img = document.createElement("img");
img.src = "https://cdn.freecodecamp.org/curriculum/cat-photo-app/lasagna.jpg";
img.alt = "A slice of lasagna on a plate.";
container.appendChild(img);
creating nodes with innerHTML and createElement() allows you to dynamically manipulate the structure and content of your websited.

Difference between innerText, textContent, innerHTML
--- innerText represents the visible text content of the HTML element and its descendants, this property doesn't include hidden text or HTML tags, only rendered text.
<div id="container">
  <p>Hello, World!</p>
  <p>I'm learning JavaScript</p>
</div>
const container = document.getElementById("container");
console.log(container.innerText); // Hello, World! and I'm learning
property returns a string with the text contained within the element. If child element is hidden, its text wont be visible
--- textContent returns the plainText content of an element, including all the text within its descendants
difference between innerText and textContent is that textContent always returns the full text content and HTML element and its descendents, regardless of whether it's visible or hidden
textContent will also include the content of elements like script and style
If you try to replace the value of textContent on a node, it will remove all its child nodes and replace them with a single text node containing the new string
Difference between innerText, textContent, innerHTML - with innerHTML you can set the inner HTML content of an element. This is helpful for injecting new HTML into the DOM dynamically.

Add and Remove nodes from the DOM with appendChild() and removeChild()
The appendChild() method is used to add a node to the end of the list of children of a specified parent node.
Syntax
parentNode.appendChild(newNode);
const dessertList = document.getElementById("desserts");
const newItem = dessertsList.createElement("li");
dessertList.appendChild(newItem) -> but last added el is empty
to add text content to the new list item element, you can use the textContent
newItem.textContent = "Cookies"
dessertList.appendChild(newItem)
The removeChild() method 
parentNode.removeChild(childNode)
const sectionEl = document.getElementById("example-section");
const lastParagraph = document.querySelector("#example-section p:last-of-type");
last-of-type -> pseudo-class to select the last element inside section element
sectionEl.removeChild(lastParagraph)

Navigator Window and Document interfaces
An interface is a collection of methods and properties that define a particular object
The Navigator interface provides information about the browser environment, such as the user agent string, the platform and the version of the browser.
A user agent string is a text that defines the browser and operating system being used
console.log(navigator.userAgent) -> result will be string that contains information about browser and operating system that being used
result's like -> Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/128.0.0.0 Safari/537.36
Another useful property of Navigator is language property, which returns the lanuage of the browser. You can use it when to display content in the user's preferred language
console.log(navigator.language) -> result will be string like en-US

The Window interface represents the browser window that contains the DOM document. It provides methods and properties for interacting with the browser window, such as resizing the window, opening new window, and navigating to different URLs
console.log(window.innerWidth) -> like 800 in pixels
console.log(window.location) -> information about the current URL of the browser window, result will be object such as protocol, hostname, pathname
Mostly you wont need to interact with the Window interface directly, as it's automatically available in the global scope
you can use location without window, like
console.log(location)-> results will be same as window.location
The Document interface represents the DOM document that is displayed in the browser window. It provides methods and properties for interacting with the DOM, such as selecting elements, creating new elements, and modifying the content of elements
console.log(document.children)-> result will be HTMLCollection object that contains all the child elements of the document

add Attributes with setAttributes()
setAttribute() method to add attributes to your HTML elements
Syntax
setAttribute(attribute, value);
<p id="para">I am a paragraph</p>
to add a class attribute we need to access that p element then use setAttribute()
const paragra = document.getElementById("para")
paragra.setAttribute("class", "my-class")
console.log(${paragra.outerHTML}) ->   <p id="para" class="my-class">I am a paragraph</p>
or you can update existing attr to new one
const pEl = document.querySelector(".my-class");
pEl.setAttribute("class", "example")
console.log(${pEl.outerHTML})
if you were buildinf image gallery, you might need to update src attr of image element, when user clicks on a thumbnail

Event object
is a payload that triggers when a user interact with your web page in some way. 
These interactions can be anything from clicking on a button or focusing an input to shaking their mobile device.
Event object has a number of properties that might be helpful, properties available depend on the event that triggered this payload.
type property - reveals the type of event that triggered the payload, such as "keydown"/"click".
These values will correspond to the same values you might pass to addEventListener(), where you can capture and utilize the Event object.
target property - reference to whatever object triggered the event. This will be sort of HTML element object, or the Document/ Window objects. But it can be also something more specific, like an AudioContext.
Event also have methods which are functions exposed as properties on the object. One commonly used method is preventDefault(), which prevents the default behavior of the event when called.
If you want handle form submissions yourself, for example, you might call preventDefault() to keep the browser from trying to submit the from data as a POST request. 
stopPropagation() method - prevents the event from bubbling up or propagating to parent elements.
FetchEvent - have a request property to contain the request that triggered the event.

addEventListener() method
is used to listen for events. It takes two arguments: the event you want to listen for and a function that will be called when the event occurs
Syntax:
element.addEventListener("event", listener);
element is the HTML element to monitor for events
event specifies the type of event to listen for, such as "click"
The listener is an object that will recieve the notification when the event occurs. this will be a function that you define to handle the event.
element.addEventListener("click", ()=>{})
the listener argument can also be null, or it can be an object tha uses the EventListener interface.
EventListener defines a single method called handleEvent().
This method is automatically called whenever the event you're listening for occurs. Using this interface allows same object to handle multiple events if needed.

<button id="btn">Show alert</button>
const btn = document.getElementById("btn");
btn.addEventListener("click", ()=> alert("You cliked the button"))

<input type="text" id="input" placeholder="Type something" />
const input = document.getElementById("input");
input.addEventListener("input", ()=>{
  console.log(input.value)
})
There are common events include mouseover, mouseout, keydown, keyup, submit

removeEventListener() method
is used to remove an event listener that was previously added to an element using the addEventListener() method.
Useful when you want to stop listening for a particular event on an element.
Syntax:
element.removeEventListener("event", listener);
There is also an additional optional third argument that can be passed to the removeEventListener() method. This argument can either be the options or useCapture.
The options is an object that specifies the options for the event listener, such as whether the event listener should be passive or once.
The useCapture is a boolean value that specifies whether the event should be captured during the event propagination phase.
Most of time you will only need to pass the event and listener arguments
We might use the removeEventListener() method in a real-world application, when modal is closed or when a user logs out

Inline Event Handlers and why is it best practice to use eddEventListener() instead
are special attributes on an HTML element that are used to execute JS code when an event occurs.
<button onclick ="alert('Hello')">Show alert</button>
when user clicks on the button, the alert function is called and an alert dialog is displayed with the msg
another way to use inline event handlers is to call a function that is defined in a script tag in HTML document.
<button onclick=""changeColor()>Change bg color</button>
<script> 
  function changeColor(){
    document.body.style.backgroundColor = "lightblue"
  }
</script>
Inline event handlers can only be used to attach one event listener to an element. If you want to attach multiple event listeners to the same element, you will need to use addEvenListener().
Inline event handlers mix HTML and JS code together, which can make your code harder to rean and maintain.
Inline event handlers are not recommended for use in modern JS.
Its better to use addEventListener()

Manipulate styles using Element.style and Element.classList
The Element.style property is a read-only property that represents the inline style of an element. You can use this property to get or set the style of an element.
<p id="para">This is a para</p>
const paraEl = document.getElementById("para")
paraEl.style.color = "red"
style property can be used to set many CSS properties, such as color, background-color, font-size, font-weight, and so on.
The Element.ClassList is a read-only property that can be used to add, remove, or toggle classes on an element.
const paraEl = document.getElementById("para")
paraEl.classList.add("highlight"); // we are adding class highlight to paragraph with id para
classList.add("class1", "class2", "class3"); //you can also add multiple classes
classList.remove("highlight"); // you can remove class from an element 
classList.toggle() // to toggle a class on an element
<button id="toggle-btn">Toggle Menu</button>
<nav id="menu" class="menu">
  <ul>
    <li>Home</li>
  </ul>
</nav>
.menu {
  display: none;
  background-color: lightgray;
  width: 50%;
  padding: 10px;
}
.menu.show {
  display: block;
}
const menu = document.getElementById("menu");
const toggleBtn = document.getElementById("toggle-btn");
toggleBtn.addEventListener("click", () => menu.classList.toggle("show"));
when user clicks on the button, the show class will be added to the .menu element, and the menu element will be displayed.
If user clicks again, the show will be removed from .menu, and menu will be hidden.

DOMContentLoaded Event 
is fired when everything in the HTML document has been loaded and pardsed. If you have external stylesheets or images, the DOMContentLoaded event will not wait for those to be loaded. It will only wait for the HTML to be loaded.
this differs from the load event, which waits for everything to be loaded, including external stylesheets, images and so on.
Syntax
document.addEventListener("DOMContentLoaded", function(){
  console.log("DOM is Loaded.")
}) //Once DOM is loaded, the function will be executed and the msg Dom is loaded, will be logged to the console.
if (document.readyState === "loading") {
  document.addEventListener("DOMContentLoaded", changeImg);
} else {
  console.log("DOMContentLoaded has already fired");
  changeImg();
}
//this code makes sure that the function changeImg() runs only after the HTML document is fully loaded and parsed, no matter when the script itself is executed.
